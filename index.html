<!doctype html>

<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Air Draw с жестами</title>
  <style>
    body {margin:0; background:#0f1724; color:#fff; font-family:sans-serif; display:flex; flex-direction:column; height:100vh}
    #stage {position:relative; flex:1; overflow:hidden}
    video, canvas {position:absolute; inset:0; width:100%; height:100%; object-fit:cover}
    video {transform:scaleX(-1)} /* зеркало */
    #controls {padding:8px; background:#111827; display:flex; gap:10px; align-items:center}
    .btn {padding:6px 10px; border:1px solid #333; background:#1f2937; color:#fff; border-radius:6px; cursor:pointer}
  </style>
</head>
<body>
  <div id="stage">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="draw"></canvas>
    <canvas id="overlay"></canvas>
  </div>
  <div id="controls">
    <button class="btn" id="clear">Очистить</button>
    <span id="status">Запуск камеры...</span>
  </div>  <!-- MediaPipe Hands -->  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.min.js"></script>  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('draw');
    const overlay = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');
    const octx = overlay.getContext('2d');
    const status = document.getElementById('status');

    let drawing = false;
    let last = null;
    let isEraser = false;

    function resize(){
      [canvas, overlay].forEach(c=>{
        c.width = stage.clientWidth;
        c.height = stage.clientHeight;
      });
    }
    window.addEventListener('resize', resize);
    resize();

    // Жесты: кулак = ластик, 2 пальца = очистка
    function detectGesture(landmarks){
      const tips = [8, 12, 16, 20]; // кончики пальцев (кроме большого)
      const mcp = [5, 9, 13, 17]; // суставы
      let extended = tips.map((tip, i)=> landmarks[tip].y < landmarks[mcp[i]].y);
      const extendedCount = extended.filter(v=>v).length;
      if (extendedCount === 0) return 'fist'; // кулак
      if (extended[0] && extended[1] && !extended[2] && !extended[3]) return 'two'; // 2 пальца
      if (extended[0] && !extended[1] && !extended[2] && !extended[3]) return 'draw'; // только указательный
      return 'none';
    }

    function drawLine(from, to, erase=false){
      ctx.save();
      ctx.globalCompositeOperation = erase ? 'destination-out' : 'source-over';
      ctx.strokeStyle = erase ? 'rgba(0,0,0,1)' : '#ff4655';
      ctx.lineWidth = erase ? 40 : 6;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(to.x, to.y);
      ctx.stroke();
      ctx.restore();
    }

    function normalizedToCanvas(p){
      return {x:p.x * canvas.width, y:p.y * canvas.height};
    }

    // MediaPipe Hands
    const hands = new Hands({locateFile: (file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.5
    });

    hands.onResults(results=>{
      octx.clearRect(0,0,overlay.width,overlay.height);
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0){
        const landmarks = results.multiHandLandmarks[0];
        drawConnectors(octx, landmarks, HAND_CONNECTIONS, {color:'#0ff', lineWidth:1});
        drawLandmarks(octx, landmarks, {color:'#f0f', lineWidth:1});

        const gesture = detectGesture(landmarks);
        status.textContent = 'Жест: ' + gesture;

        if (gesture === 'draw'){
          const tip = normalizedToCanvas(landmarks[8]);
          if (last){
            drawLine(last, tip, false);
          }
          last = tip;
        } else if (gesture === 'fist'){
          const tip = normalizedToCanvas(landmarks[8]);
          if (last){
            drawLine(last, tip, true);
          }
          last = tip;
        } else if (gesture === 'two'){
          ctx.clearRect(0,0,canvas.width,canvas.height);
          last = null;
        } else {
          last = null;
        }
      }
    });

    // Камера
    const camera = new Camera(video, {
      onFrame: async()=>{ await hands.send({image:video}); },
      width: 640,
      height: 480
    });
    camera.start();

    document.getElementById('clear').addEventListener('click', ()=>{
      ctx.clearRect(0,0,canvas.width,canvas.height);
    });
  </script></body>
</html>    // События указателя / касания
    function pointerDown(e){
      e.preventDefault();
      drawing = true;
      last = getPos(e);
    }
    function pointerMove(e){
      if (!drawing) return;
      const pos = getPos(e);
      drawLine(last, pos);
      last = pos;
    }
    function pointerUp(e){
      drawing = false;
    }

    // Подключаем обработчики
    function attachDrawingHandlers(){
      canvas.addEventListener('pointerdown', pointerDown);
      canvas.addEventListener('pointermove', pointerMove);
      window.addEventListener('pointerup', pointerUp);

      // Для старых браузеров и тачей
      canvas.addEventListener('touchstart', pointerDown, {passive:false});
      canvas.addEventListener('touchmove', pointerMove, {passive:false});
      canvas.addEventListener('touchend', pointerUp);
    }

    // Управление камерой
    async function getCameras(){
      try{
        const devices = await navigator.mediaDevices.enumerateDevices();
        const cams = devices.filter(d => d.kind === 'videoinput');
        cameraSelect.innerHTML = '';
        cams.forEach((c,i)=>{
          const opt = document.createElement('option');
          opt.value = c.deviceId;
          opt.textContent = c.label || `Камера ${i+1}`;
          cameraSelect.appendChild(opt);
        });
      }catch(err){console.warn(err)}
    }

    async function startCamera(deviceId){
      if (currentStream){
        currentStream.getTracks().forEach(t=>t.stop());
        currentStream = null;
      }
      const constraints = {
        video: deviceId ? {deviceId:{exact:deviceId}} : {facingMode:'environment'},
        audio: false
      };
      try{
        status.textContent = 'Запуск камеры...';
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        currentStream = stream;
        video.srcObject = stream;
        await video.play();
        status.textContent = 'Камера включена';

        // После запуска камеры скорректируем размеры canvas
        resize();
      }catch(err){
        console.error(err);
        status.textContent = 'Ошибка доступа к камере';
      }
    }

    // Сохранение — мы рисуем кадр видео на временном canvas, затем накладываем рисунок
    function saveImage(){
      const out = document.createElement('canvas');
      out.width = canvas.width; out.height = canvas.height;
      const octx = out.getContext('2d');
      // Важно: видео имеет transform:scaleX(-1) для зеркала, учтем это
      octx.save();
      // Масштабируем под devicePixelRatio
      const ratio = window.devicePixelRatio || 1;
      octx.scale(ratio, ratio);
      // Нарисуем видео (не зеркально) — если page зеркален, то перевернём
      const stageRect = canvas.getBoundingClientRect();
      // drawImage принимает размеры в реальных пикселях, поэтому используем video.videoWidth/video.videoHeight
      // Чтобы корректно вписать видео в canvas, используем cover-like drawing
      const vw = video.videoWidth, vh = video.videoHeight;
      const cw = stageRect.width, ch = stageRect.height;
      // compute source rect to cover
      const videoRatio = vw/vh; const canvasRatio = cw/ch;
      let sx=0, sy=0, sw=vw, sh=vh;
      if (videoRatio > canvasRatio){
        // video wider -> crop sides
        const desiredW = vh * canvasRatio;
        sx = (vw - desiredW)/2; sw = desiredW;
      } else {
        // video taller -> crop top/bottom
        const desiredH = vw / canvasRatio;
        sy = (vh - desiredH)/2; sh = desiredH;
      }
      // учитываем зеркальность на странице
      const mirrored = getComputedStyle(video).transform.includes('-1') || getComputedStyle(video).transform.includes('scaleX(-1)');
      if (mirrored) {
        octx.translate(cw, 0);
        octx.scale(-1,1);
      }
      octx.drawImage(video, sx, sy, sw, sh, 0, 0, cw, ch);
      octx.restore();

      // затем наложим рисунок (canvas) — но remember canvas is already scaled to DPR, so draw full size
      octx.drawImage(canvas, 0, 0, out.width, out.height);

      // формируем dataURL и сохраняем
      const data = out.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = data; a.download = 'camera-draw.png';
      document.body.appendChild(a); a.click(); a.remove();
    }

    // Инициализация UI
    (async function init(){
      attachDrawingHandlers();
      window.addEventListener('resize', resize);

      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
        status.textContent = 'Ваш браузер не поддерживает getUserMedia.';
        return;
      }

      await getCameras();
      // Запускаем камеру (попытка сначала environment)
      await startCamera();

      // Если список камер доступен, автоматически выбрать и дать возможность переключать
      cameraSelect.addEventListener('change', ()=>{
        startCamera(cameraSelect.value);
      });

      // Управление инструментами
      eraserBtn.addEventListener('click', ()=>{
        isEraser = !isEraser; eraserBtn.textContent = isEraser ? 'Карандаш' : 'Ластик';
      });
      clearBtn.addEventListener('click', ()=>{ ctx.clearRect(0,0,canvas.width,canvas.height); });
      saveBtn.addEventListener('click', saveImage);

      toggleMirrorBtn.addEventListener('click', ()=>{
        const mirrored = video.style.transform === 'scaleX(-1)';
        if (mirrored){ video.style.transform = 'scaleX(1)'; toggleMirrorBtn.textContent = 'Зеркало: Выкл'; }
        else { video.style.transform = 'scaleX(-1)'; toggleMirrorBtn.textContent = 'Зеркало: Вкл'; }
      });

      // Предотвратить прокрутку страницы при рисовании на мобильных
      document.body.addEventListener('touchmove', function(e){ if (e.target === canvas) e.preventDefault(); }, {passive:false});

      // Начальное ресайз
      setTimeout(resize, 250);
    })();
  </script></body>
</html>
